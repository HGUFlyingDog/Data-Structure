# 开发记录

* [x] 冒泡排序

* [ ] 简单选择排序

* [ ] 快速排序
* [ ] 直接插入排序（链表）
* [ ] 希尔排序
* [ ] 堆排序

## 冒泡排序

出现的问题：会写单趟排序，但是把一趟改成多趟的时候会出现一些奇怪的问题

改进小措施，在我写检验校验数组的排序结果部分的时候，我想到了如果加一个`flag`来表示我的数组是否已经有序了，如果有序的话那么`flag`就会等于`1`，然后检测一下`flag `的结果来判断时候已经有序，但是经过测试时间提升的好像不是很明显

改进之后的代码：

```c
void BubbleSort(int* a, int n)
{
	for (int j = n - 1; j >= 0; j--)
	{
		int flag = 0;//增加flag
		for (int i = 0; i < j; i++)
		{
			if (a[i] >a[i + 1])
				swap(a[i], a[i + 1]);
			flag = 1;
		}
		if (flag == 0)
		{
			break;
		}
	}
}
```



## 其他的小组件

### 基于范围的for循环

在C++11中，增加了一个特性叫做基于范围的for循环，可以~~好玩的~~去打印数组

原始打印如下：

```c++
for (int i = 0; i < sizeof(arr) / sizeof(int); ++i)
	cout << arr[i] << " ";
```

但是基于范围的for循环就很好玩,也很简单

```c++
for (auto x : arr)
	{
		cout << x << " ";
	}
```

### 校验数组的排序结果

```c++
void CheckSort(int* a, int n)
{
	for (int i = 0; i < n-1; i++)
	{
		//if (a[i] >= a[i + 1]) 这里不能用>= ，更正如下：
        if (a[i] > a[i + 1])
		{
			cout << "排序未完成" << endl;
		}
	}
}
```



